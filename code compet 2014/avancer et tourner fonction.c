#pragma config(Sensor, S1,     sonarSensor,    sensorSONAR)
#pragma config(Sensor, S2,     capteurTouchGauche, sensorTouch)
#pragma config(Sensor, S3,     capteurTouchDroite, sensorTouch)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

void avancerObstacle();
void avancer();
void reculer();
void avancerDroite();
void avancerGauche();
int reculerDroite();
int reculerGauche();
void tournerDroite();
void tournerGauche();

task main()
{
	int continuer = 1;
	while(continuer)
	{
		//avancer();//25 = 400, 50 = 800, 100 = 1450, 150 = 2150 , 200 = 2950,
		//avancerObstacle();
		//reculer();
		//avancerGauche();
		//avancerDroite();
		//reculerDroite();
		//reculerGauche();
		tournerGauche(); // quart de tour = 165, demi tour = 320 , trois quart = 485, tour = 635,
		//tournerDroite();
		//moitieDroite();

		//avancerObstacle();

		continuer = 0;
	}
}


void avancerObstacle()
{
	nSyncedMotors = synchAB;
  nSyncedTurnRatio = 100; //motors move in opposite directions of each other
	int speed = 0;
  int sonarValue = 0;
	int limiteDistance = 15;

	sonarValue = SensorValue(sonarSensor);

		while(sonarValue > limiteDistance)
		{
			sonarValue = SensorValue(sonarSensor);

			wait1Msec(100);
			speed = (SensorValue(sonarSensor) - limiteDistance);
			if(speed > 80)
			{
				speed = 80;
			}
			motor[motorA] = speed;
		}
		motor[motorA] = 0;
}

void avancer()
{
	nSyncedMotors = synchAB;
  nSyncedTurnRatio = 100; //motors move in opposite directions of each other
  nMotorEncoder[motorA] = 0;
	nMotorEncoderTarget[motorA] = 400;
	motor[motorA] = 100;
	while(nMotorRunState[motorA] != runStateIdle)    // While the Touch Sensor is inactive (hasn't been pressed):
	{}
	motor[motorA] = 0;
}

void reculer()
{
	nSyncedMotors = synchAB;
  nSyncedTurnRatio = 100; //motors move in opposite directions of each other
  nMotorEncoder[motorA] = 0;
	nMotorEncoderTarget[motorA] = 650;
	motor[motorA] = -100;
	while(nMotorRunState[motorA] != runStateIdle)    // While the Touch Sensor is inactive (hasn't been pressed):
	{}
	motor[motorA] = 0;
}

void avancerDroite()
{
	int sonarValue = 0;
	nSyncedMotors = synchAB; //motor A is the master, motor B is the slave
	nSyncedTurnRatio = 50;
	nMotorEncoder[motorA] = 0;
	nMotorEncoderTarget[motorA] = 600;
	motor[motorA] = 100;
	sonarValue = SensorValue(sonarSensor);
	while(sonarValue > 15 && nMotorRunState[motorA] != runStateIdle)    // While the Touch Sensor is inactive (hasn't been pressed):
	{
		sonarValue = SensorValue(sonarSensor);
	}
	motor[motorA] = 0;
}

void avancerGauche()
{
	int sonarValue = 0;
	nSyncedMotors = synchBA; //motor A is the master, motor B is the slave
	nSyncedTurnRatio = 50;
	nMotorEncoder[motorB] = 0;
	nMotorEncoderTarget[motorB] = 900;
	motor[motorB] = 100;
	while(sonarValue > 15 && nMotorRunState[motorB] != runStateIdle)    // While the Touch Sensor is inactive (hasn't been pressed):
  {
  	sonarValue = SensorValue(sonarSensor);
  }
  motor[motorB] = 0;
 	//return 1;
}

int reculerGauche()
{
	int valeurCapteurDroit; // 1023 bouton relacher 183 bouton appuyer
	int valeurCapteurGauche;
	nSyncedMotors = synchAB; //motor A is the master, motor B is the slave
	nSyncedTurnRatio = 50;
	nMotorEncoder[motorA] = 0;
	nMotorEncoderTarget[motorA] = 800;
	motor[motorA] = -100;
	valeurCapteurDroit = SensorValue(capteurTouchDroite);
	valeurCapteurGauche = SensorValue(capteurTouchGauche);
	wait1Msec(200);
	while(valeurCapteurGauche == 1023 && valeurCapteurDroit == 1023 && nMotorRunState[motorA] != runStateIdle)    // While the Touch Sensor is inactive (hasn't been pressed):
  {
  	valeurCapteurDroit = SensorValue(capteurTouchDroite);
	  valeurCapteurGauche = SensorValue(capteurTouchGauche);
  }
  motor[motorA] = 0;
	if(valeurCapteurGauche < 1000)
	{
		return 1;
	}
	else if(valeurCapteurDroit < 1000)
	{
		return 2;
	}
	else
	{
		return 0;
	}
}

int reculerDroite()
{
	int valeurCapteurDroit; // 1023 bouton relacher 183 bouton appuyer
	int valeurCapteurGauche;
	nSyncedMotors = synchBA; //motor A is the master, motor B is the slave
	nSyncedTurnRatio = 50;
	nMotorEncoder[motorB] = 0;
	nMotorEncoderTarget[motorB] = 800;
	motor[motorB] = -100;
	valeurCapteurDroit = SensorValue(capteurTouchDroite);
	valeurCapteurGauche = SensorValue(capteurTouchGauche);
	while(valeurCapteurGauche == 1023 && valeurCapteurDroit == 1023 && nMotorRunState[motorB] != runStateIdle)    // While the Touch Sensor is inactive (hasn't been pressed):
  {
  	valeurCapteurDroit = SensorValue(capteurTouchDroite);
	  valeurCapteurGauche = SensorValue(capteurTouchGauche);
  }
  motor[motorB] = 0;
	if(valeurCapteurGauche < 1000)
	{
		return 1;
	}
	else if(valeurCapteurDroit < 1000)
	{
		return 2;
	}
	else
	{
		return 0;
	}
}

void tournerGauche()
{
	nSyncedMotors = synchAB; //motor A is the master, motor B is the slave
	nSyncedTurnRatio = -100;
	nMotorEncoder[motorA] = 0;
	nMotorEncoderTarget[motorA] = 485; // 280 passer d'un extreme  l'autre donc 140 du milieu  un extreme
	motor[motorA] = 100;
	while (nMotorRunState[motorA] != runStateIdle)
	{}
	motor[motorA] = 0;
}

void tournerDroite()
{
	nSyncedMotors = synchBA; //motor A is the master, motor B is the slave
	nSyncedTurnRatio = -100;
	nMotorEncoder[motorB] = 0;
	nMotorEncoderTarget[motorB] = 150; // 280 passer d'un extreme  l'autre donc 140 du milieu  un extreme
	motor[motorB] = 100;
	while (nMotorRunState[motorB] != runStateIdle)
	{}
	motor[motorB] = 0;
}
