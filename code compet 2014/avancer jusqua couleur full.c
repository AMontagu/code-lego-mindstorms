#pragma config(Sensor, S1,     sonarSensor,    sensorSONAR)
#pragma config(Sensor, S2,     capteurTouchGauche, sensorTouch)
#pragma config(Sensor, S3,     capteurTouchDroite, sensorTouch)
#pragma config(Sensor, S4,     couleur,        sensorColorNxtFULL)
#pragma config(MotorPidSetting,  motorA,  255, 255, 65535, 255, 255,   65535, 65535, 65535)
#pragma config(MotorPidSetting,  motorB,  255, 255, 65535, 255, 255,   65535, 65535, 65535)
#pragma config(MotorPidSetting,  motorC,  255, 255, 65535, 255, 255,   65535, 65535, 65535)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

int avancerLigne();
int avancerTest(int passerCouleur);
void avancerEncore(int nombreTour);

task main()
{
	int valeurCapteurLumiere;
	int doubleLigne = 0;
	int passerCouleur = 6;
	nSyncedMotors = synchAB;
	nSyncedTurnRatio = 100;

	while(true)
	{
		wait1Msec(200);
		valeurCapteurLumiere = SensorValue(couleur);
		wait1Msec(200);
		if((valeurCapteurLumiere == 6 || valeurCapteurLumiere == 1) && (passerCouleur == 6 || passerCouleur == 1))
		{
			passerCouleur = avancerLigne();
		}
		else
		{
			nxtDisplayCenteredTextLine(5, "passer %d", passerCouleur);
			doubleLigne = avancerTest(passerCouleur);
			passerCouleur = 6;
		}
		if(doubleLigne != 0)
		{
			if(doubleLigne == 1)
			{
				playSound(soundBlip);
				wait1Msec(1000);
				playSound(soundBlip);
				wait1Msec(1000);
				playSound(soundBlip);
			}
			else
			{
				playSound(soundDownwardTones);
			}
			doubleLigne = 0;
		}
	}
}

int avancerLigne()
{
	int valeurCapteurLumiere = 0;
	nSyncedMotors = synchAB;
  nSyncedTurnRatio = 100; //motors move in opposite directions of each other
  nMotorEncoder[motorA] = 0;
	nMotorEncoderTarget[motorA] = 30;
	motor[motorA] = 20;
	valeurCapteurLumiere = SensorValue(couleur);
	nxtDisplayCenteredTextLine(7, "%d", valeurCapteurLumiere);
	//wait1Msec(2000);
	while(nMotorRunState[motorA] != runStateIdle && (valeurCapteurLumiere == 6 || valeurCapteurLumiere == 1))    // While the Touch Sensor is inactive (hasn't been pressed):
	{
		valeurCapteurLumiere = SensorValue(couleur);
	}
	motor[motorA] = 0;
	nxtDisplayCenteredTextLine(3, "retour %d", valeurCapteurLumiere);
	return valeurCapteurLumiere;
}

int avancerTest(int passerCouleur)
{
	int valeurCapteurLumiere = 0;
	nSyncedMotors = synchAB;
  nSyncedTurnRatio = 100; //motors move in opposite directions of each other
  nMotorEncoder[motorA] = 0;
	nMotorEncoderTarget[motorA] = 40;
	motor[motorA] = 30;
	while(nMotorRunState[motorA] != runStateIdle)    // While the Touch Sensor is inactive (hasn't been pressed):
	{}
	motor[motorA] = 0;

	wait1Msec(1000);
	valeurCapteurLumiere = SensorValue(couleur);

	if(valeurCapteurLumiere == passerCouleur)
	{
		return 1;
	}
	else
	{
	  avancerEncore(13);

		wait1Msec(1000);
		valeurCapteurLumiere = SensorValue(couleur);

		if(valeurCapteurLumiere == passerCouleur)
		{
			return 1;
		}
		else
		{
			avancerEncore(13);

			wait1Msec(1000);
			valeurCapteurLumiere = SensorValue(couleur);

			if(valeurCapteurLumiere == passerCouleur)
			{
				return 1;
			}
			else
			{
				avancerEncore(13);

				wait1Msec(1000);
				valeurCapteurLumiere = SensorValue(couleur);

				if(valeurCapteurLumiere == passerCouleur)
				{
					return 1;
				}
				else
				{
					return 2;
				}
			}
		}
	}
}

void avancerEncore(int nombreTour)
{
	nMotorEncoder[motorA] = 0;
	nMotorEncoderTarget[motorA] = nombreTour;
	motor[motorA] = 30;
	while(nMotorRunState[motorA] != runStateIdle)    // While the Touch Sensor is inactive (hasn't been pressed):
	{}
	motor[motorA] = 0;
}
